渲染进程内分为`主线程(main thread)`、`工作线程(worker thread)`、`合成线程(compositor thread)`和`光栅线程(raster thread)`

# 解析DOM(DOM Tree)

`主线程`把`HTML`文本数据转化为`DOM`对象，`DOM`既是浏览器对当前页面的内部表示，也是前端开发人员通过`JavaScript`与网页交互的对象。


`主线程`在解析`HTML`的过程中会遇到`CSS`样式、`JavaScript`脚本和图片等资源，如果遇到`script`标签时`主线程`会暂停`HTML`的解析，直到`JS`代码下载并执行完成，而`CSS`则不会阻塞`HTML`的解析。

### 提示
如果`JS`代码中不包括操作DOM的内容，那`主线程`就无需在此时阻塞`HTML`解析，在`script`标签中指定`async`或`defer`来向主线程提示你应该继续解析`HTML`。

# 解析CSS(CSSOM Tree)
`主线程`完成`HTML`解析后无法确定页面长什么样，因为还缺少一些样式,`主线程`会根据页面中的`CSS`来计算出每个DOM节点对应的样式

# 布局(Layout Tree)
有了`DOM对象`和对应的`CSS`样式后,`主线程`还会根据一些列复杂的规则来生成一颗`布局树`，它由`DOM树`和`CSSOM树`再加上几何信息(例如位置、大小等信息)构成。

在这个过程中会有非常多的`CSS`属性在增加`布局树`的复杂度，例如`float`、`position`和`overflow`等

无需在页面中呈现的内容都不应该存在`布局树`中，而`布局树`中的内容也可能比`DOM树`更多,例如`::after伪类`等

# 绘画(paint records)
我们还需要知道绘画的顺序才能渲染出界面，如果按照`布局树`的顺序绘制，那么`z-index`属性可能会界面不正确的遮挡，所以在这个步骤`主线程`会遍历`布局树`来生成一个`绘画记录(paint records)`，这是绘画过程中的指导，指明绘画顺序。

# 分层(Layer Tree)

`主线程` 把页面分成多个`层`，然后一次把它们分别`光栅化`(把布局树信息转化为显示器像素的过程称之为光栅化),分层规则浏览器有自己的规则，不过开发者也可通过CSS的`will-change`属性来告诉浏览器对齐分层。

可以通过`开发人员工具`(F12)，通过3D标签页查看分层信息。

# 合成

由于需要显示的数据已经被光栅化，因此视口需要被显示的部分可以直接合成显示

`合成线程`会把页面分成`块`(tiles)，然后交给`光栅线程`，`光栅线程`光栅化这些块后会把结构放进GPU的内存中。

# 参考

详细请查看 [窥探现代浏览器架构(三)](https://zhuanlan.zhihu.com/p/101587249)